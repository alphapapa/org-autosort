#+AUTHORS: yantar92
#+EMAIL: yantar92@gmail.com
#+OPTIONS: tags:nil todo:nil num:nil
#+PROPERTY: header-args :tangle no

* NEXT Automatic sorting of items in org mode                        :COMMON:
:LOGBOOK:
- State "NEXT"       from "NEXT"       [2018-01-01 Mon 13:31]
- State "NEXT"       from "NEXT"       [2018-01-01 Mon 13:21]
CLOCK: [2017-12-25 Mon 21:58]--[2017-12-25 Mon 22:00] =>  0:02
:END:
** Motivation
For now, standard org capabilities allow to sort entries in the agenda
views automatically. However, sorting of the actual org files is
rather limited. We only have =org-sort= function, which allows to sort
by one criteria only (not like =org-agenda-sorting-strategy= with
multiple sort criteria). Moreover, it can be done manually only.  

Sometimes, one may have a need to look at some kind of long list of
TODO items (for example, this infinitely growing list of things you
wish to do one day, or list of ideas). It is not comfortable to scroll
across such kind of list to look for specific item. Sorting is
something, that can help here.

*************** TODO Add some example here              :NOEXPORT:
*************** END

Of course, you can still use =org-sort= or agenda view with restriction
to the current subtree, but it may be disrupting if you want to look
through multiple of such a lists.  

The solution is to implement automatic sorting of subtrees in org
files.

** Overview
This package aims to implement an automatic sorting of the subtrees
in org files. The sorting order can be set globally through all the
org files, locally in file, or locally in a subtree using =:SORT:=
property.  

Everything, except global sorting order, can be set using standard
inheritance capabilities of the org properties (file local, subtree
local with or without inheritance for subtrees inside the
subtree). Global sorting order can be set via
=org-autosort-global-sorting-strategy= variable.

** Configuration

Both =:SORT:= property and =org-autosort-global-sorting-strategy=
are lists, which determine how to sort the entries.

<<org-autosort-global-sorting-strategy>>
=org-autosort-global-sorting-strategy= defines how to sort entries by
default. It is a list of [[sorting rules][sorting rules]], defining the comparison
between sorted entries. First, the entries are sorted via first rule
from the list. If the calculated keys are equal, second rule is used,
and so on.

=:SORT:= can be either =nil=, =t=, or the same format as
=org-autosort-global-sorting-strategy=:
- =t= :: use =org-autosort-global-sorting-strategy=
- not defined or =nil= :: sort if =org-autosort-sort-all= is non =nil=
- empty or =none= :: do not sort entries
- list :: define separate sorting strategy 

The sorting can be done after:
- opening the org file
- =org-autosort-sort-entries-at-point= command
- =org-autosort-sort-entries-in-file= command
(see [[sorting triggers][sorting triggers]] for details)

** Defaults
:PROPERTIES:
:CREATED:  [2017-12-25 Mon 16:06]
:END:
The package provide some predefined sorting rules <<sorting rules>>,
all are listed in =org-autosort-functions-alist=.

#+begin_src emacs-lisp :noweb yes
<<autosort-functions>>
#+end_src

You can control automatic sorting by setting <<sorting triggers>>

#+BEGIN_SRC elisp :noweb yes
<<autosort-triggers>>
#+END_SRC

Default [[org-autosort-global-sorting-strategy][sorting strategy]] is

#+BEGIN_SRC elisp :noweb yes
<<autosort-default-strategy>>
#+END_SRC

** NEXT Implementation                                            :NOEXPORT:
:PROPERTIES:
:header-args: :tangle yes
:END:
:LOGBOOK:
CLOCK: [2017-12-10 Sun 17:36]--[2017-12-10 Sun 20:02] =>  2:26
CLOCK: [2017-12-10 Sun 10:21]--[2017-12-10 Sun 11:02] =>  0:41
:END:
*** DONE Header
CLOSED: [2017-12-11 Mon 15:58]
:PROPERTIES:
:ID:       3e603efc-e71a-4520-bcef-265cff481455
:END:
#+begin_src emacs-lisp
;;; org-autosort.el --- Sort entries in org files automatically -*- lexical-binding: t; -*-

;; Version: 0.11
;; Author: Ihor Radchenko <yantar92@gmail.com>
;; Created: 10 Dec 2017
;; Keywords: matching, outlines
;; Homepage: https://github.com/yantar92/org-autosort
;; Package-Requires: (org)

;;; Commentary:

;; This package aims to implement an automatic sorting of the subtrees in org files.
;; The sorting order can be set globally through all the org files, locally in file, or locally in a subtree using :SORT: property.

;;; Code:
#+end_src
*** DONE Custom variables
CLOSED: [2017-12-18 Mon 21:23]
:PROPERTIES:
:ID:       08e58824-f88a-4d3b-a79e-00a1514eb68a
:END:
:LOGBOOK:
CLOCK: [2017-12-10 Sun 17:13]--[2017-12-10 Sun 17:33] =>  0:20
CLOCK: [2017-12-10 Sun 11:03]--[2017-12-10 Sun 11:35] =>  0:32
CLOCK: [2017-12-10 Sun 11:02]--[2017-12-10 Sun 11:03] =>  0:01
:END:
#+begin_src emacs-lisp
(defgroup org-autosort nil
  "Customization options of org-autosort package.")
#+end_src
- to sort or not to sort
#+begin_src emacs-lisp
(defcustom org-autosort-sort-all nil
  "Sort entries if :SORT: property is not defined.")
#+end_src
- auto sort triggers
#+name: autosort-triggers
#+begin_src emacs-lisp
(defcustom org-autosort-sort-at-file-open t
  "Non nil states for sorting of all items in the org file after opening."
  :type '(boolean))
#+end_src
- predefined sorts
#+name: autosort-functions
#+begin_src emacs-lisp
(defcustom org-autosort-functions-alist '((todo-up-0 . (:key org-autosort-get-todo :cmp <)) ; default org-sort comparison
					  (todo-down-0 . (:key org-autosort-get-todo :cmp >))
					  ;; compare according to `org-autosort-todo-cmp-order'
					  (todo-up . (:key org-get-todo-state :cmp org-autosort-custom-cmp-todo))
					  (todo-down . (:key org-get-todo-state :cmp (lambda (a b)
										       (not (org-autosort-custom-cmp-todo a b)))))
					  ;;					  
					  (text-up . (:key org-autosort-get:cmp :cmp string<))
					  (text-down . (:key org-autosort-get-text :cmp string>))
                                          (priority-up . (:key (org-autosort-get-property "PRIORITY") :cmp string<))
                                          (priority-down . (:key (org-autosort-get-property "PRIORITY") :cmp string>)))
  "Alist, defining aliases to sorting rules.
Each value in the list defines a sorting rule.
The rule is a property list with :key and :cmp properties.

:key property defines a function to calculate the key value.
:cmp property defines a function to compare the keys.
In both cases, function can be defined as
 1. lambda expression
 2. function symbol
 3. list, containing function symbol or lambda expression and their arguments

:key function is called with pos at the entry, without arguments.
If :key is defined as in 3, all the nesessary arguments should be in the list.

:cmp function must accept two arguments (after all the arguments as in 3).
It must satisfy the rules of cmp function for `sort'.
If :cmp is omitted, `org-autosort-default-cmp-function' is used."
  :type '(alist :key-type symbol
		:value-type (plist :value-type (choise function
						       (list function (repeat sexp))))))

(defcustom org-autosort-default-cmp-function #'string<
  "Default function, used to compare two entry keys.
Can be also a list of function and its arguments.
It is used if cmp function is not defined.
It must accept two arguments - first and second sorting key to compare.
Non nil return value means that first key is lesser than second key."
  :type '(function))
#+end_src
- default sorting strategy
#+name: autosort-default-strategy
#+begin_src emacs-lisp
(defcustom org-autosort-global-sorting-strategy '(priority-down todo-up)
  "Sorting strategy, used to sort entries with :SORT: property not set or nil.
This is a list, which elements can be:
- key of the sorting rule from `org-autosort-functions-alist'
- sorting rule, defined as in `org-autosort-functions-alist'
- :key values as from `org-autosort-functions-alist'
Sorting rules are applied accorting the their position in the list.
nil means that no sorting should be done by default."
  :type '(choice symbol
		 (plist :value-type (choise function
					    (list function (repeat sexp))))))
#+end_src
*** NEXT Standard sorting functions
:PROPERTIES:
:ID:       c478d941-ddbf-49cc-b38c-a03c33779817
:END:
:LOGBOOK:
CLOCK: [2017-12-18 Mon 20:59]--[2017-12-18 Mon 21:21] =>  0:22
CLOCK: [2017-12-10 Sun 17:08]--[2017-12-10 Sun 17:13] =>  0:05
:END:
**** NEXT List compare function
:PROPERTIES:
:CREATED:  [2017-12-29 Fri 05:48]
:END:
Compare arguments according to the list argument provided, so that
matching items will be sorted as in the list, and non matching will be
moved to the end. List entries can be regex.
**** NEXT by property
:PROPERTIES:
:ID:       51552471-6f2b-4792-a8a3-b4bb0d3618d8
:END:
#+begin_src emacs-lisp 
(defun org-autosort-get-property (property)
  "Get the value of PROPERTY for sorting."
  (org-entry-get (point)
		 property
		 'selective))
#+end_src
**** NEXT By todo keyword
:PROPERTIES:
:ID:       0d4d78c1-a4a2-4091-8142-ea9e70434d73
:END:
#+begin_src emacs-lisp 
(defun org-autosort-get-todo ()
  "Get the value of todo keyword for sorting." ; stolen from org-sort-entries in org.el
  (let* ((m (org-get-todo-state))
	 (s (if (member m
			org-done-keywords) '- '+))
	 )
    (- 99
       (funcall s
		(length (member m
				org-todo-keywords-1))))))
#+end_src
**** NEXT By todo keyword, custom
:PROPERTIES:
:ID:       87e5b164-fe1f-4618-9b07-741c27e37bc0
:END:
#+BEGIN_SRC emacs-lisp
(defvar org-autosort-todo-cmp-order nil
  "Order of todo keywords to be shown in sorted subtrees.
       Follow `org-todo-keywords-1' if nil."
  )
(defun org-autosort-custom-cmp-todo (a b)
  "Compare todo keywords A and B.  Return non nil if A<B."
  (let* ((todo-cmp-orgder (or org-autosort-todo-cmp-order
			      org-todo-keywords-1))
	 (posa (or (seq-position org-autosort-todo-cmp-order
				 a)
		   0))
	 (posb (or (seq-position org-autosort-todo-cmp-order
				 b)
		   0)))
    (< posa posb)))
#+END_SRC
**** NEXT Alphabetic
SCHEDULED: <2017-12-12 Tue>
:PROPERTIES:
:ID:       5205ed5d-cb92-4711-86b7-c2bf9549f0f5
:END:
:LOGBOOK:
CLOCK: [2017-12-18 Mon 20:33]--[2017-12-18 Mon 20:50] =>  0:17
:END:
#+BEGIN_SRC emacs-lisp
(defun org-autosort-get-text ()
  "Get the text or tags (if text is empty) of the current entry."
  (nth 4 (org-heading-components))
  )
#+END_SRC
**** TODO By first inactive timestamp
**** TODO By deadline
**** TODO By clocking time
**** TODO Numerically, beginning of the entry/item
**** TODO By scheduled time/date
**** TODO By active timestamp
**** TODO By any timestamp
*** DONE [#A] General sorting routine
CLOSED: [2017-12-25 Mon 22:00] SCHEDULED: <2017-12-18 Mon>
:PROPERTIES:
:ID:       7b077f97-a744-4197-9b4f-015af71ab95f
:END:
:LOGBOOK:
CLOCK: [2017-12-25 Mon 15:14]--[2017-12-25 Mon 15:18] =>  0:04
- Note taken on [2017-12-18 Mon 21:21] \\
  Lambda cannot be recognized in sorting strategy since it is a list. Need to do something with it.
  CLOCK: [2017-12-10 Sun 20:48]--[2017-12-10 Sun 22:40] =>  1:52
  CLOCK: [2017-12-10 Sun 16:24]--[2017-12-10 Sun 17:36] =>  1:12
  CLOCK: [2017-12-10 Sun 16:05]--[2017-12-10 Sun 16:06] =>  0:01
  CLOCK: [2017-12-10 Sun 14:17]--[2017-12-10 Sun 16:02] =>  1:45
  CLOCK: [2017-12-10 Sun 11:35]--[2017-12-10 Sun 13:58] =>  2:23
:END:
#+begin_src emacs-lisp
(defun org-autosort-sorting-strategy-elementp (elm)
  "Validate element ELM of sorting strategy.  Return (:key ... [:cmp ...]) if element and nil otherwise."
  (pcase elm
    (`(quote val)
     (org-autosort-sorting-strategy-elementp val))
    ((pred functionp)
     (list :key elm))
    ((pred (lambda (arg) (assoc arg org-autosort-functions-alist)))
     (alist-get elm org-autosort-functions-alist))
    ((pred (lambda (arg) (plist-get arg :key)))
     (let ((key (org-autosort-sorting-strategy-elementp (plist-get elm :key)))
	   (cmp (org-autosort-sorting-strategy-elementp (plist-get elm :cmp))))
       (cond ((and key (not cmp)) key)
	     ((and key cmp) (plist-put key :cmp (plist-get cmp :key)))
	     (t nil))))
    (`(,func . ,args)
     (if (functionp func)
	 (list :key elm)
       nil))
    (_ nil)))

(defun org-autosort-sorting-strategyp (sorting-strategy)
  "Validate if SORTING-STRATEGY is a valid and return it.
The strategy is ensured to be a list.
Signal user error and return nil if argument is not a sorting strategy."
  (if (not sorting-strategy)
      nil
    (or (let ((res (org-autosort-sorting-strategy-elementp sorting-strategy)))
	  (if res (list res)))
	(let* ((testresult (mapcar (lambda (elm) (cons (org-autosort-sorting-strategy-elementp elm)
						  elm))
				   sorting-strategy))
	       (err-elm (alist-get nil testresult 'none)))
	  (if (equal err-elm 'none)
	      sorting-strategy
	    nil
	    (user-error "org-autosort: Wrong element of sorting strategy: \"%s\" in buffer: %s"
			err-elm (buffer-name)))))))

(defun org-autosort-get-sorting-strategy ()
  "Get sorting strategy at point for the current entry's subtree being sorted."
  (let ((property (org-entry-get (point) "SORT" 'selective)))
    (pcase property
      ('t (org-autosort-sorting-strategyp org-autosort-global-sorting-strategy))
      ('nil (and org-autosort-sort-all
	       (org-autosort-sorting-strategyp org-autosort-global-sorting-strategy)))
      ("" nil)
      ('none nil)
      (_ (if (= (cdr (read-from-string property))
		(length property))
	     (org-autosort-sorting-strategyp (car (read-from-string property)))
	   (user-error "org-autosort: Cannot read :SORT: property: \"%s\" in buffer: %s" property (buffer-name))
	   nil)))))

(defun org-autosort-construct-get-value-function-atom (sorting-strategy-elm)
  "Construct get-value function for single element of sorting strategy (SORTING-STRATEGY-ELM)."
  (let ((key (plist-get (org-autosort-sorting-strategy-elementp sorting-strategy-elm) :key)))
    (pcase key
      ((pred functionp)
       key)
      (`(,func . ,args)
       (when (functionp func)
	 (lambda () (apply (car key) (cdr key)))))
      ('nil (lambda () nil)))))

(defun org-autosort-construct-get-value-function ()
  "Return get-value function at point.
This function returns a list of sorting keys."
  (let ((sorting-strategy (org-autosort-get-sorting-strategy)))
    (if sorting-strategy
	(let ((func-list (mapcar #'org-autosort-construct-get-value-function-atom sorting-strategy)))
	  (lambda () (mapcar #'funcall func-list)))
      (lambda () (list nil)))))

(defun org-autosort-construct-cmp-function-atom (sorting-strategy-elm)
  "Construct cmp function for single element of sorting strategy (SORTING-STRATEGY-ELM)."
  (let* ((sorting-strategy-elm (org-autosort-sorting-strategy-elementp sorting-strategy-elm))
	 (cmp (and sorting-strategy-elm
		   (or (plist-get sorting-strategy-elm :cmp)
		       org-autosort-default-cmp-function))))
    (pcase cmp
      ((pred functionp)
       (lambda (a b) (funcall cmp a b)))
      (`(,func . ,args)
       (when (functionp func)
	 (lambda (a b) (apply func a b args))))
      ('nil (lambda (a b) nil)))))

(defun org-autosort-construct-cmp-function ()
  "Return cmp function at point."
  (let ((sorting-strategy (org-autosort-get-sorting-strategy)))
    (if (not sorting-strategy)
	(lambda (lista listb) nil)
      (let ((cmp-func-list (mapcar #'org-autosort-construct-cmp-function-atom sorting-strategy)))
	(lambda (lista listb)
	  (let ((resultlist (seq-mapn (lambda (func a b)
					(cons (funcall func a b)
					      (funcall func b a)))
				      cmp-func-list lista listb)) ; list of cons (a<b . b<a)
		(done nil)
		result)
	    (while (and (not done)
			(not (seq-empty-p resultlist)))
	      (let ((elem (pop resultlist)))
		(unless (and (car elem)
			   (cdr elem)) ; not equal
		  (setq done t)
		  (setq result (car elem)))))
	    result))))))

(defun org-autosort-org-sort-entries-wrapper (&rest args)
  "Run `org-sort-entries' at point with ARGS if nesessary.
Make sure, folding state is not changed."
  (when (org-autosort-get-sorting-strategy)
    (save-excursion
      (save-restriction
	(condition-case err
	    (apply #'org-sort-entries args)
	  (user-error
	   (unless (string-match-p "Nothing to sort"
				   (error-message-string err))
	     (signal (car err) (cdr err)))))))))

(defun org-autosort-sort-entries-at-point-nonrecursive ()
  "Sort org-entries at point nonrecursively."
  (interactive)
  (funcall #'org-autosort-org-sort-entries-wrapper
	   nil ?f
	   (org-autosort-construct-get-value-function)
	   (org-autosort-construct-cmp-function)))

(defun org-autosort-sort-entries-at-point-recursive ()
  "Sort org-entries at point recursively."
  (interactive)
  (condition-case err
      (org-map-entries (lambda nil (funcall #'org-autosort-org-sort-entries-wrapper
				     nil ?f
				     (org-autosort-construct-get-value-function)
				     (org-autosort-construct-cmp-function)))
		       nil 'tree)
    (error
     (if (string-match-p "Before first headline at position"
			 (error-message-string err))
	 (org-map-entries (lambda nil (funcall #'org-autosort-org-sort-entries-wrapper
					nil ?f
					(org-autosort-construct-get-value-function)
					(org-autosort-construct-cmp-function)))
			  nil 'file)
       (signal (car err) (cdr err))))))

(defun org-autosort-sort-entries-at-point (&optional ARG)
  "Sort org entries at point.
Sort recursively if invoked with \\[universal-argument]."
  (interactive "P")
  (if (equal ARG '(4))
      (org-autosort-sort-entries-at-point-recursive)
    (org-autosort-sort-entries-at-point-nonrecursive)))

(defun org-autosort-sort-entries-in-file ()
  "Sort all entries in the file recursively."
  (interactive)
  (org-map-entries (lambda nil (funcall #'org-autosort-org-sort-entries-wrapper
				 nil ?f
				 (org-autosort-construct-get-value-function)
				 (org-autosort-construct-cmp-function)))
		   nil 'file))

(defun org-autosort-sort-entries-in-file-maybe ()
  "Sort all entries in the file recursively if `org-autosort-sort-at-file-open' is not nil."
  (when org-autosort-sort-at-file-open (org-autosort-sort-entries-in-file)))

(add-hook 'org-mode-hook #'org-autosort-sort-entries-in-file-maybe)
#+end_src
*** DONE File epilogue
CLOSED: [2017-12-10 Sun 19:40]
:PROPERTIES:
:ID:       cf53b069-fcbb-45f9-9a80-e05f88d1fec5
:END:
#+begin_src emacs-lisp 
(provide 'org-autosort)

;;; org-autosort.el ends here
#+end_src
** Ideas                                                     :SKIP:NOEXPORT:
:PROPERTIES:
:SORT:     (todo-down)
:END:
*** TODO Sort only items, matching org search regex
*** TODO should be able to define alias in sorting strategy
:PROPERTIES:
:CREATED:  [2017-12-18 Mon 20:58]
:END:
:LOGBOOK:
CLOCK: [2017-12-18 Mon 20:58]--[2017-12-18 Mon 20:59] =>  0:01
:END:
*** TODO use local hook in autosort for toggle hooks
:PROPERTIES:
:CREATED:  [2017-12-20 Wed 15:23]
:END:
*** TODO add this functionality? [[http://sachachua.com/blog/2017/12/sorting-org-mode-lists-using-a-sequence-of-regular-expressions/][Sorting Org Mode lists using a sequence of regular expressions  13]] :COMMON:
:PROPERTIES:
:CREATED:  [2017-12-21 Thu 23:50]
:Source:   http://sachachua.com/blog/2017/12/sorting-org-mode-lists-using-a-sequence-of-regular-expressions/
:END:
*** TODO Add trigger to not read lisp from sort property it is not safe
:PROPERTIES:
:CREATED:  [2017-12-25 Mon 22:05]
:END:
*** TODO sort signalling error -resolve [[id:e9132d5f-cc43-4bae-b9ed-244e21e8b8cc][Test test]]
:PROPERTIES:
:CREATED: [2017-12-29 Fri 22:37]
:END:
:LOGBOOK:
CLOCK: [2017-12-29 Fri 22:37]--[2017-12-29 Fri 22:38] =>  0:01
:END:
** NEXT Versions                                                  :NOEXPORT:
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:15]
:END:
:LOGBOOK:
CLOCK: [2017-12-29 Fri 05:59]--[2017-12-29 Fri 06:00] =>  0:01
:END:
*** NEXT 1.0
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:15]
:ORDERED:  t
:END:
:LOGBOOK:
CLOCK: [2017-12-29 Fri 05:50]--[2017-12-29 Fri 05:59] =>  0:09
:END:
- =org-agenda-sorting-strategy= like sorting specs <<v1.1>>
- sort entries in file on open <<v1.2>>
- sort entries in place <<v1.3>>
- sort lists <<v1.4>>
- construct comparison function with the list of items/regex, which
  should be placed on the top no matter what <<v1.5>>
- update the sort on changes, including creating new entries <<v1.6>>
- interactive sort via subtree agenda invocation, similar to filtering
  <<v1.7>>
*************** TODO Make it noweb refs, insert into files
*************** END

**** NEXT [#A] 0.1
SCHEDULED: <2018-01-13 Sat>
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
[[v1.1][specs]], [[v1.2][on open]]
***** DONE 0.10
CLOSED: [2018-01-01 Mon 13:21]
:PROPERTIES:
:CREATED:  [2018-01-01 Mon 13:18]
:END:
:LOGBOOK:
- State "DONE"       from              [2018-01-01 Mon 13:21]
:END:
****** DONE allow to define sort criteria like a lisp function in the properties field
CLOSED: [2017-12-12 Tue 21:18]
****** CANCELLED Take care about exact position for =C-c C-c= (say, we are inside the table - user may not want to sort) :CANCELLED:
CLOSED: [2017-12-11 Mon 16:56]
:LOGBOOK:
- State "CANCELLED"  from "TODO"          [2017-12-11 Mon 16:56]
:END:
****** CANCELLED do not use org-sort, because it does not allow to combine sorts (i.e. sort by one criteria, if equal - by other) :CANCELLED:
CLOSED: [2017-12-12 Tue 21:18]
:LOGBOOK:
- State "CANCELLED"  from "TODO"          [2017-12-12 Tue 21:18] \\
  Made a proper wrapper
:END:
***** DONE 0.11
CLOSED: [2018-01-01 Mon 13:21]
:PROPERTIES:
:CREATED:  [2018-01-01 Mon 13:18]
:END:
:LOGBOOK:
- State "DONE"       from              [2018-01-01 Mon 13:21]
:END:
****** DONE put buffer name in error report for wrong element of sorting strategy
CLOSED: [2017-12-25 Mon 21:59]
:PROPERTIES:
:CREATED:  [2017-12-18 Mon 20:57]
:END:
****** DONE Handle nothing to sort
CLOSED: [2017-12-11 Mon 16:56] SCHEDULED: <2017-12-11 Mon>
:LOGBOOK:
CLOCK: [2017-12-11 Mon 16:24]--[2017-12-11 Mon 16:56] =>  0:32
CLOCK: [2017-12-11 Mon 15:58]--[2017-12-11 Mon 16:08] =>  0:10
:END:
****** DONE make interactive versions of sorting functions
CLOSED: [2017-12-25 Mon 21:59]
****** DONE rewrite sorting strategy to use assoc lists
CLOSED: [2017-12-25 Mon 21:58]
:PROPERTIES:
:CREATED:  [2017-12-18 Mon 21:21]
:END:
:LOGBOOK:
CLOCK: [2017-12-25 Mon 15:18]--[2017-12-25 Mon 21:58] =>  6:40
CLOCK: [2017-12-18 Mon 21:21]--[2017-12-18 Mon 21:25] =>  0:04
:END:
****** DONE do not raise error but put a message and do not sort on wrong :SORTING: format
CLOSED: [2017-12-25 Mon 22:00]
:PROPERTIES:
:CREATED:  [2017-12-23 Sat 11:21]
:END:
***** NEXT 0.12
:PROPERTIES:
:CREATED:  [2018-01-01 Mon 13:21]
:END:
****** TODO add hooks to to autosort
:PROPERTIES:
:CREATED:  [2017-12-18 Mon 09:56]
:END:
****** NEXT get rid of annoying unfolding after =org-sort=
:PROPERTIES:
:CREATED:  [2017-12-18 Mon 20:54]
:END:
:LOGBOOK:
CLOCK: [2017-12-18 Mon 20:57]--[2017-12-18 Mon 20:58] =>  0:01
CLOCK: [2017-12-18 Mon 20:54]--[2017-12-18 Mon 20:57] =>  0:03
:END:

**** TODO 0.2
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
:LOGBOOK:
- State "TODO"       from "NEXT"          [2018-01-01 Mon 13:22]
:END:
[[v1.3][interactive in place]],[[v1.4][list sort]], [[v1.5][comparison list]]
**** TODO 0.3
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
[[v1.6][adaptive sort update]]
***** TODO Share on reddit
:PROPERTIES:
:CREATED:  [2017-12-29 Fri 05:57]
:END:
**** TODO 0.4
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
[[v1.7][interactive sort via agenda]]
**** 0.5
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
**** 0.6
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
**** 0.7
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
**** 0.8
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
**** 0.9
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
**** 1.0
:PROPERTIES:
:CREATED:  [2017-12-28 Thu 23:16]
:END:
